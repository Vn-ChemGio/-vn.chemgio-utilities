import { Signer } from './utils/signer';declare global {  /**   * PangeaConfig options   */  export interface ConfigOptions {    /** Pangea API domain. */    domain?: string;        /**     * Pangea environment.     *     * This is intended to facilitate SDK development and should not be touched in     * everyday usage.     */    environment?: ConfigEnv;        /** Config ID for multi-config projects. */    configID?: string;        /**     * Whether or not to perform requests via plain HTTP, as opposed to secure     * HTTPS.     */    insecure?: boolean;        /** How many times a request should be retried on failure. */    requestRetries?: number;        /** Maximum allowed time (in milliseconds) for a request to complete. */    requestTimeout?: number;        /** Whether or not queued request retries are enabled. */    queuedRetryEnabled?: boolean;        /** Timeout for polling results after a HTTP/202 (in milliseconds). */    pollResultTimeoutMs?: number;        /** How many queued request retries there should be on failure. */    queuedRetries?: number;        /** User-Agent string to append to the default one. */    customUserAgent?: string;  }    export interface PostOptions {    pollResultSync?: boolean;    files?: FileItems;  }    export enum ConfigEnv {    LOCAL = 'local',    PRODUCTION = 'production',  }    export enum TransferMethod {    MULTIPART = 'multipart',    POST_URL = 'post-url',    PUT_URL = 'put-url',    SOURCE_URL = 'source-url',    DEST_URL = 'dest-url',  }    export interface Dictionary {    [key: string]: string | boolean | number | Dictionary;  }    export interface FileData {    file: Buffer | string;    name: string;    file_details?: Dictionary;  }    export interface FileUploadParams {    size: number;    crc32c: string;    sha256: string;  }    export interface FileItems {    [key: string]: FileData;  }    export interface AcceptedResult {    ttl_mins: number;    retry_counter: number;    location: string;    post_url?: string;    put_url?: string;    post_form_data?: Dictionary;  }    /**   * Secure Audit interface definitions   */  export namespace Audit {    export interface LogOptions {      verbose?: boolean;      signer?: Signer;      skipEventVerification?: boolean;      verify?: boolean;      publicKeyInfo?: Object; // Key:Value object    }        export interface LogEvent {      event: Audit.Event;      signature?: string;      public_key?: string;    }        export interface LogRequestCommon {      verbose?: boolean;    }        export interface LogData extends LogEvent, LogRequestCommon {      event: Audit.Event;      prev_root?: string;      config_id?: string;    }        export interface LogBulkRequest extends LogRequestCommon {      events: Audit.LogEvent[];    }        export interface Event {      message: string;      action?: string;      source?: string;      target?: string;      actor?: string;      tenant_id?: string;      new?: string;      old?: string;      status?: "COMPLETED"|"FAILED";      timestamp?: Date,    }        export type EventData = Pick<Event, 'message'|'action'|'source'|'target'|'new'|'old'|'status'|'timestamp'>        export interface EventEnvelope {      event: Event;      signature?: string;      public_key?: string;      received_at: string;    }        export interface AuditRecord {      envelope: Audit.EventEnvelope;      hash: string;      membership_proof?: string;      published?: boolean;      leaf_index?: string;      consistency_verification?: string;      membership_verification?: string;      signature_verification?: string;    }        export interface Root {      url?: string;      published_at?: string;      size: number;      root_hash: string;      consistency_proof: string[];      tree_name: string;    }        export interface LogResponse {      hash: string;      envelope: Audit.EventEnvelope;      unpublished_root?: string;      membership_proof?: string;      consistency_proof?: string[];      consistency_verification?: string;      membership_verification?: string;      signature_verification?: string;    }        export interface LogBulkResponse {      results: LogResponse[];    }        export interface SearchOptions {      verifyConsistency?: boolean;      skipEventVerification?: boolean;    }        export interface SearchResponse {      id: string;      expires_at: string;      count: number;      events: Audit.AuditRecord[];      root?: Root;      unpublished_root?: Root;    }        export interface SearchRestriction {      actor?: Array<string>;      action?: Array<string>;      source?: Array<string>;      status?: Array<string>;      target?: Array<string>;    }        export interface SearchParamsOptions {      limit?: number;      max_results?: number;      start?: string;      end?: string;      order?: string;      order_by?: string;      search_restriction?: Audit.SearchRestriction;      verbose?: boolean;    }        export interface SearchParams extends SearchParamsOptions {      query: string;    }        export interface RootParams {      tree_size?: number;    }        export interface ResultResponse {      events: AuditRecord[];      count: number;      root?: Root;    }        export interface RootRequest {      tree_size?: number;    }        export interface RootResult extends Root {      data: Root;    }        export enum DownloadFormat {      /**       * JSON.       */      JSON = 'json',            /**       * CSV.       */      CSV = 'csv',    }        export interface DownloadRequest {      /**       * ID returned by the search API.       */      result_id: string;            /**       * Format for the records.       */      format?: DownloadFormat;    }        export interface DownloadResult {      /**       * URL where search results can be downloaded.       */      dest_url: string;    }  }}export {}